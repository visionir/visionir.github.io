<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅谈JAVA十大排序算法（一）</title>
      <link href="/2019/10/25/19/"/>
      <url>/2019/10/25/19/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈java十大排序算法一"><a class="markdownIt-Anchor" href="#浅谈java十大排序算法一"></a> 浅谈JAVA十大排序算法（一）</h1><h2 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h2><p>冒泡排序的基本原理是比较相邻的两个元素，如果第一个元素大于(小于)第二个元素则交换他们，从第一组到最一组都进行比较即为完成一轮(最后一组的最后元素为已排序序列)，依次对未排序好的序列进行比较直到完成排序。</p><p>这里我们按照从小到大的顺序进行排序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bubbleSort</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] bubbleSorted(<span class="keyword">int</span>[] sortArray) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = sortArray.length;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sortArray;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sortArray, sortArray.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">            a[i]=(<span class="keyword">int</span>)(Math.random()*<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bubbleSort b=<span class="keyword">new</span> bubbleSort();</span><br><span class="line">        <span class="keyword">int</span>[] ss=b.bubbleSorted(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d:ss)&#123;</span><br><span class="line">            System.out.print(d+<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果如下:</p><p><img alt="冒泡排序" data-src="https://s2.ax1x.com/2019/10/25/KdHjjP.png" class="lozad"></p><h2 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h2><p>选择排序的原理是将未排序序列中的最大(小)值与未排序序列首个元素互换位置同时缩小未排序序列的范围直至排序结束。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">selectSort</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] SelectSort(<span class="keyword">int</span>[] sortArray) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = sortArray.length;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sortArray;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sortArray, sortArray.length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[min]&gt;arr[j])&#123;</span><br><span class="line">                    min=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">            arr[i]=arr[min];</span><br><span class="line">            arr[min]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">            a[i]=(<span class="keyword">int</span>)(Math.random()*<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        selectSort b=<span class="keyword">new</span> selectSort();</span><br><span class="line">        <span class="keyword">int</span>[] ss=b.SelectSort(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d:ss)&#123;</span><br><span class="line">            System.out.print(d+<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果如下:</p><p><img alt="选择排序" data-src="https://i.loli.net/2019/10/25/WSbgDRJarxnpq6i.png" class="lozad"></p><h2 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h2><p>插入排序的原理是将第一个元素作为中心，第二个至最后一个依次扫描，放置中心元素的左边或者右边的正确位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">insertSort</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] InsertSort(<span class="keyword">int</span>[] sortArray) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = sortArray.length;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sortArray;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sortArray, sortArray.length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">            <span class="keyword">int</span> j=i;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span>&amp;&amp;temp&lt;arr[j-<span class="number">1</span>])&#123;</span><br><span class="line">                arr[j]=arr[j-<span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">            a[i]=(<span class="keyword">int</span>)(Math.random()*<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        insertSort b=<span class="keyword">new</span> insertSort();</span><br><span class="line">        <span class="keyword">int</span>[] ss=b.InsertSort(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d:ss)&#123;</span><br><span class="line">            System.out.print(d+<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果如下：</p><p><img alt="插入排序" data-src="https://s2.ax1x.com/2019/10/25/KwZaC9.png" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> JAVA SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础(二)</title>
      <link href="/2019/10/16/18/"/>
      <url>/2019/10/16/18/</url>
      
        <content type="html"><![CDATA[<h1 id="接口和抽象类的区别是什么"><a class="markdownIt-Anchor" href="#接口和抽象类的区别是什么"></a> 接口和抽象类的区别是什么？</h1><ul><li>接口中的所有方法都是抽象的，而抽象类中的方法既可以包含抽象方法也可以包含非抽象方法。</li><li>一个类可以实现多个接口，但只能直接继承一个抽象类。</li><li>接口中声明的变量默认是public static final类型的，而抽象类可以声明非final类型的变量。</li><li>接口是设计的结果，抽象类是重构的结果。</li><li>在JDK 8中接口中可以定义拥有方法体的静态方法和普通方法，普通方法必须显示标注default关键字。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">Amain</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Amain"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticAmain</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"staticAmain"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="jdk-和-jre-有什么区别"><a class="markdownIt-Anchor" href="#jdk-和-jre-有什么区别"></a> JDK 和 JRE 有什么区别？</h1><p>JRE(Java Runtime Environment)是java的运行环境，包括了jvm虚拟机、核心类库以及支持文件。</p><p>JDK(Java Development Kit) 是 Java 语言的软件开发工具包，包括了JRE以及开发工具。</p><h1 id="string-stri与-string-strnew-stringi的区别"><a class="markdownIt-Anchor" href="#string-stri与-string-strnew-stringi的区别"></a> String str=&quot;i&quot;与 String str=new String(“i”)的区别？</h1><p>String str=“i” JVM会在常量池中查找是否存在&quot;i&quot;，如果存在则直接在栈内存中开辟空间str来存储&quot;i&quot;在常量池中的地址值；如果不存在则需先在常量池中开辟空间存储&quot;i&quot;，再在栈内存中开辟空间str来存储&quot;i&quot;在常量池中的地址值。因此会创建一个或不创建对象。</p><p>String str=new String(“i”)JVM会在常量池中查找是否存在&quot;i&quot;，如果不存则在常量池中开辟空间存储&quot;i&quot;,在运行时期，通过String类的构造器在堆内存中创建空间将常量池中的“&quot;i&quot;复制一份存放到该堆空间，然后在栈内存中开辟空间str存放堆中所创建对象的地址值。这种情况下至少创建了一个对象，可以能创建了两个。</p><h1 id="list-set-map-之间的区别"><a class="markdownIt-Anchor" href="#list-set-map-之间的区别"></a> List、Set、Map 之间的区别</h1><h2 id="有序性"><a class="markdownIt-Anchor" href="#有序性"></a> 有序性</h2><p>List保证了元素的插入顺序，可以通过索引获取元素；Set、Map对元素进行无序存储，不能保证元素的顺序，但LinkedHashSet按照元素的插入顺序进行排列，TreeMap根据键对元素进行升序排列。</p><h2 id="重复性"><a class="markdownIt-Anchor" href="#重复性"></a> 重复性</h2><p>List允许插入重复的元素，Set不允许插入重复值，当插入重复值时将返回false，Map是以键值对的形式存储元素的，因此Map不允许键重复。</p><h2 id="空值性"><a class="markdownIt-Anchor" href="#空值性"></a> 空值性</h2><p>List允许任意数量的空值；</p><p>Set只允许一个空值；</p><p>Map只允许一个空键，但允许出现多个空值。</p><h2 id="关于重复性的重要关键点"><a class="markdownIt-Anchor" href="#关于重复性的重要关键点"></a> 关于重复性的重要关键点</h2><p><font color="#FF5722">由于Set、Map的子类多种多样，诸如HashSet、HashMap等以键的hashcode值作是否属于重复元素的集合在存储元素时需要将自定义类的hashcode()方法重写，否则无法保证集合的不可重复性；而诸如TreeMap、TreeSet等为了保证key值的唯一，调用了 Comparable 的 compareTo()方法，因此必须在自定义类中实现Comparable接口并重写 compareTo()方法，否则无法保证集合的不可重复性。</font></p><h1 id="抽象类能使用-final-修饰吗"><a class="markdownIt-Anchor" href="#抽象类能使用-final-修饰吗"></a> 抽象类能使用 final 修饰吗？</h1><p>抽象类定义就是为了让其他类继承，如果定义final就不能被继承，两者相互矛盾。</p><p><img alt="abstract和final" data-src="https://s2.ax1x.com/2019/10/16/KijrkV.png" class="lozad"></p><h1 id="java-中-io-流分为几种"><a class="markdownIt-Anchor" href="#java-中-io-流分为几种"></a> Java 中 IO 流分为几种？</h1><p><img alt="IO流" data-src="https://s2.ax1x.com/2019/10/16/KF0bGQ.png" class="lozad"></p><p>java中的IO流分为字符流和字节流：</p><p>按流：输出流：OutputStream、Writer</p><p>​            输入流：InputStream、Reader</p><p>按处理数据单元：字节流：字节输入流：InputStream</p><p>​                                              字节输出流：OutputStream</p><p>​                               字符流：字符输入流：Reader</p><p>​                                               字节输出流：Writer</p><p><b>FileOutputStream</b>：指文本字节输出流，用于将原始字节流如图像等写入文件中。该类共有5个构造方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name, <span class="keyword">boolean</span> append)</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file, <span class="keyword">boolean</span> append)</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(FileDescriptor fdObj)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>其中的boolean append参数表示是否追加写入；若为true，则追加写入；若为false则写入到文件的开头，覆盖内容。</p><p><code>FileOutputStream可以用于生成系统文件，当文件不存在时会自动创建该文件并写入数据。</code></p><p><strong>DataOutputStream</strong>：数据输出流，允许应用程序以与机器无关方式将Java基本数据类型写到底层输出流。</p><p><strong>ObjectOutputStream</strong>：对象输出流，处理序列化(指将对象保存为二进制字节码的过程)的流，用于将对象写入文件(对象必须实现Serializable接口)。</p><p><strong>BufferedOutputStream</strong>：字节缓冲输出流，是一种高效流(提供了一个缓冲数组，先将数据写入缓冲区再写入物理数据源中)，无无参构造方法，必须传入OutputStream对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new buffered output stream to write data to the</span></span><br><span class="line"><span class="comment">     * specified underlying output stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   out   the underlying output stream.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedOutputStream</span><span class="params">(OutputStream out)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(out, <span class="number">8192</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new buffered output stream to write data to the</span></span><br><span class="line"><span class="comment">     * specified underlying output stream with the specified buffer</span></span><br><span class="line"><span class="comment">     * size.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   out    the underlying output stream.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   size   the buffer size.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span> IllegalArgumentException if size &amp;lt;= 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedOutputStream</span><span class="params">(OutputStream out, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(out);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size &lt;= 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>FileInputStream</strong>：文本字节输入流，指对文件以字节的形式进行读取文本图片等，共有3中构造方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(FileDescriptor fdObj)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>DataInputStream</strong>：数据输入流，允许应用程序以机器无关的方式从底层输入流中读取基本的Java类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DataInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>ObjectInputStream</strong>：对象输入流，处理反序列化(指从文件中读取对象)的流，对象必须实现Serializable接口。</p><p><strong>BufferedInputStream</strong>：字节缓冲输入流，是一种高效流(提供了一个缓冲数组,从缓冲区读取数据比直接从物理数据源读取速度要快)，同样无无参构造方法，必须传入InputStream对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &lt;code&gt;BufferedInputStream&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * and saves its  argument, the input stream</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;in&lt;/code&gt;, for later use. An internal</span></span><br><span class="line"><span class="comment">     * buffer array is created and  stored in &lt;code&gt;buf&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   in   the underlying input stream.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &lt;code&gt;BufferedInputStream&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * with the specified buffer size,</span></span><br><span class="line"><span class="comment">     * and saves its  argument, the input stream</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;in&lt;/code&gt;, for later use.  An internal</span></span><br><span class="line"><span class="comment">     * buffer array of length  &lt;code&gt;size&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * is created and stored in &lt;code&gt;buf&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   in     the underlying input stream.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   size   the buffer size.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> size &lt;= 0&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size &lt;= 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>BudderedWriter</strong>：缓冲字符输出流，是一种高效流(提供了一个缓冲数组，先将数据写入缓冲区再写入物理数据源中)，同样无无参构造方法，必须传入Writer对象。</p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedWriter</span><span class="params">(Writer out)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(out, defaultCharBufferSize);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedWriter</span><span class="params">(Writer out, <span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(out);</span><br><span class="line">        <span class="keyword">if</span> (sz &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size &lt;= 0"</span>);</span><br><span class="line">        <span class="keyword">this</span>.out = out;</span><br><span class="line">        cb = <span class="keyword">new</span> <span class="keyword">char</span>[sz];</span><br><span class="line">        nChars = sz;</span><br><span class="line">        nextChar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        lineSeparator = java.security.AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> sun.security.action.GetPropertyAction(<span class="string">"line.separator"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;<span class="comment">//写入单个字符。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> []cbuf,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span><span class="comment">//写入字符数据的一部分。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String s,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span><span class="comment">//写入字符串的一部分。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span><span class="comment">//写入行分隔符。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;<span class="comment">//刷新该流中的缓冲区,将数据写到目的文件中。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;<span class="comment">//关闭该流。</span></span><br></pre></td></tr></table></figure><p><strong>BufferedReader</strong>：缓冲字符输入流，是一种高效流(提供了一个缓冲数组,从缓冲区读取数据比直接从物理数据源读取速度要快)，同样无无参构造方法，必须传入Reader对象。</p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a buffering character-input stream that uses an input buffer of</span></span><br><span class="line"><span class="comment">    * the specified size.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  in   A Reader</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  sz   Input-buffer size</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@exception</span>  IllegalArgumentException  If &#123;<span class="doctag">@code</span> sz &lt;= 0&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BufferedReader</span><span class="params">(Reader in, <span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(in);</span><br><span class="line">       <span class="keyword">if</span> (sz &lt;= <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size &lt;= 0"</span>);</span><br><span class="line">       <span class="keyword">this</span>.in = in;</span><br><span class="line">       cb = <span class="keyword">new</span> <span class="keyword">char</span>[sz];</span><br><span class="line">       nextChar = nChars = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a buffering character-input stream that uses a default-sized</span></span><br><span class="line"><span class="comment">    * input buffer.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  in   A Reader</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BufferedReader</span><span class="params">(Reader in)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(in, defaultCharBufferSize);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>主要方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>;<span class="comment">//读取单个字符。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span>;<span class="comment">//将字符读入到数组的一部分。返回读取的字符数。尾部返回-1。</span></span><br><span class="line"><span class="function">String <span class="title">readLine</span><span class="params">()</span></span>;<span class="comment">//读取文本行。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;<span class="comment">//关闭该流,释放与该流相关的资源。</span></span><br></pre></td></tr></table></figure><p><strong>InputStreamReader</strong>：将字节流转换为字符流的类，可以通过制定的字符集读取字节并解码。</p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an InputStreamReader that uses the default charset.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  in   An InputStream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sd = StreamDecoder.forInputStreamReader(in, <span class="keyword">this</span>, (String)<span class="keyword">null</span>); <span class="comment">// ## check lock object</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// The default encoding should always be available</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an InputStreamReader that uses the named charset.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  in</span></span><br><span class="line"><span class="comment">     *         An InputStream</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  charsetName</span></span><br><span class="line"><span class="comment">     *         The name of a supported</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@link</span> java.nio.charset.Charset charset&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span>  UnsupportedEncodingException</span></span><br><span class="line"><span class="comment">     *             If the named charset is not supported</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in, String charsetName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">        <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charsetName"</span>);</span><br><span class="line">        sd = StreamDecoder.forInputStreamReader(in, <span class="keyword">this</span>, charsetName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an InputStreamReader that uses the given charset.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  in       An InputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  cs       A charset</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@spec</span> JSR-51</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in, Charset cs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">        <span class="keyword">if</span> (cs == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charset"</span>);</span><br><span class="line">        sd = StreamDecoder.forInputStreamReader(in, <span class="keyword">this</span>, cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an InputStreamReader that uses the given charset decoder.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  in       An InputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  dec      A charset decoder</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@spec</span> JSR-51</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in, CharsetDecoder dec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">        <span class="keyword">if</span> (dec == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charset decoder"</span>);</span><br><span class="line">        sd = StreamDecoder.forInputStreamReader(in, <span class="keyword">this</span>, dec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取设置的字符集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEncoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sd.getEncoding();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取流并返回单个字符，文件末尾返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sd.read();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取字符到字符数组的部分中，文件末尾返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sd.read(cbuf, offset, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测流是否准备读取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sd.ready();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 关闭流，释放资源</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        sd.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>**OutputStreamWriter **：将字符流转换为字节流的类，可以通过制定的字符集将字符编码为字节。</p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an OutputStreamWriter that uses the named charset.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  out</span></span><br><span class="line"><span class="comment">     *         An OutputStream</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  charsetName</span></span><br><span class="line"><span class="comment">     *         The name of a supported</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@link</span> java.nio.charset.Charset charset&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span>  UnsupportedEncodingException</span></span><br><span class="line"><span class="comment">     *             If the named encoding is not supported</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OutputStreamWriter</span><span class="params">(OutputStream out, String charsetName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(out);</span><br><span class="line">        <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charsetName"</span>);</span><br><span class="line">        se = StreamEncoder.forOutputStreamWriter(out, <span class="keyword">this</span>, charsetName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an OutputStreamWriter that uses the default character encoding.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  out  An OutputStream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OutputStreamWriter</span><span class="params">(OutputStream out)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(out);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            se = StreamEncoder.forOutputStreamWriter(out, <span class="keyword">this</span>, (String)<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an OutputStreamWriter that uses the given charset.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  out</span></span><br><span class="line"><span class="comment">     *         An OutputStream</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  cs</span></span><br><span class="line"><span class="comment">     *         A charset</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@spec</span> JSR-51</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OutputStreamWriter</span><span class="params">(OutputStream out, Charset cs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(out);</span><br><span class="line">        <span class="keyword">if</span> (cs == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charset"</span>);</span><br><span class="line">        se = StreamEncoder.forOutputStreamWriter(out, <span class="keyword">this</span>, cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an OutputStreamWriter that uses the given charset encoder.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  out</span></span><br><span class="line"><span class="comment">     *         An OutputStream</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  enc</span></span><br><span class="line"><span class="comment">     *         A charset encoder</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@spec</span> JSR-51</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OutputStreamWriter</span><span class="params">(OutputStream out, CharsetEncoder enc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(out);</span><br><span class="line">        <span class="keyword">if</span> (enc == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charset encoder"</span>);</span><br><span class="line">        se = StreamEncoder.forOutputStreamWriter(out, <span class="keyword">this</span>, enc);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *写入单一字符</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        se.write(c);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *写入字符数组的一部分到流中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        se.write(cbuf, off, len);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *写入字符串的一部分到流中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        se.write(str, off, len);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *刷新流</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        se.flush();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *关闭流，释放资源</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        se.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>FileWriter和FileReader</strong>:用来实现将字符读写到文件的IO类。</p><p><code>在使用流结束后记住关闭流，以免造成资源浪费。</code></p><h1 id="collection-和-collections-有什么区别"><a class="markdownIt-Anchor" href="#collection-和-collections-有什么区别"></a> Collection 和 Collections 有什么区别？</h1><p>Collection是java集合中的一个接口，它提供了对List、Set集合对象进行基本操作的通用接口方法；</p><p>Collections是一个工具类，提供的很多的静态方法供Collection使用。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA SE </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础(一)</title>
      <link href="/2019/10/15/17/"/>
      <url>/2019/10/15/17/</url>
      
        <content type="html"><![CDATA[<h1 id="和有什么区别"><a class="markdownIt-Anchor" href="#和有什么区别"></a> &amp;和&amp;&amp;有什么区别？</h1><p>&amp;称为按位与,&amp;&amp;称为逻辑与。&amp;&amp;具有短路的功能,即前面的表达式值为false时,后面的表达式不进行运算,比如在校验用户登录时用户名应为 <code>username!=null &amp;&amp; username.euqals(&quot;&quot;)</code>。</p><h1 id="int和integer有什么区别"><a class="markdownIt-Anchor" href="#int和integer有什么区别"></a> int和Integer有什么区别？</h1><p>int类型是java的基本数据类型,而Integer是int的包装类型,属于引用类型,Java为每一个基本数据类型都引入了对应的包装类型。</p><p><img alt="数据结构" data-src="https://s2.ax1x.com/2019/10/15/KPRLTI.png" class="lozad"></p><p><img alt="数据类型" data-src="https://s2.ax1x.com/2019/10/15/KPWp6g.png" class="lozad"></p><h1 id="在web应用开发过程中经常遇到输出某种编码的字符如iso8859-1等如何输出一个某种编码的字符串"><a class="markdownIt-Anchor" href="#在web应用开发过程中经常遇到输出某种编码的字符如iso8859-1等如何输出一个某种编码的字符串"></a> 在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">translate</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String tempStr = <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tempStr = <span class="keyword">new</span> String(str.getBytes(<span class="string">"ISO-8859-1"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">            tempStr = tempStr.trim();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tempStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="string和stringbufferstringbuilder的区别"><a class="markdownIt-Anchor" href="#string和stringbufferstringbuilder的区别"></a> String和StringBuffer,StringBuilder的区别</h1><p>三者实现了CharSequence接口且是final类型的，String是不可变字符序列，底层依靠<code>private final char value[]</code> 实现，对String对象的操作都会产生新的String对象。后两者都继承自AbstratStringBuilder底层依赖的是<code>char value[]</code>，是可变字符序列，值在创建后可以改变，两者的区别在于StringBuffer是线程安全的，StringBuilder是非线程安全的。</p><h1 id="数组array和列表arraylist的区别什么时候应该使用array而不是arraylist"><a class="markdownIt-Anchor" href="#数组array和列表arraylist的区别什么时候应该使用array而不是arraylist"></a> 数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？</h1><p>Array和ArrayList底层都是数组，ArrayList只能存储基本数据类型，而Array能不但可以存储基本数据类型还能存储引用类型，Array的大小是固定的，而ArrayList的大小是动态变化的，当数组长度确定且数据类型一致时使用Array较方便。</p><h1 id="为什么会出现40-36040000001这种现象"><a class="markdownIt-Anchor" href="#为什么会出现40-36040000001这种现象"></a> 为什么会出现4.0-3.6=0.40000001这种现象？</h1><p>java采用了IEE754浮点数格式，计算机内部是以二进制形式存储数据的，由于计算机内存有限，因此在存储二进制为无限位的小数时，在某个精度点直接舍弃多余位数，所以会产生误差，<strong>但在存储二进制位数有限且分母是2的倍数的小数时能够精确的存储。</strong></p><h1 id="符号和equals比较的是什么"><a class="markdownIt-Anchor" href="#符号和equals比较的是什么"></a> 符号“==”和equals比较的是什么？</h1><p>“==”比较的两个引用是否指向同一个对象，如果是基本类型比较则是比较值是否相同；</p><p>equals比较的是两个对象的值是否相同，如果类没有重写equals方法，调用的则是Object类中的euqals方法，而Object类中的方法返回的是“==”的调用结果。</p><h1 id="为什么重写equals还要重写hashcode"><a class="markdownIt-Anchor" href="#为什么重写equals还要重写hashcode"></a> 为什么重写equals还要重写hashcode？</h1><p>Object类默认的equals比较的是两个对象的内存地址。而hashcode是本地方法，java的内存是安全的，无法根据散列码得到对象的内存地址，hashcode是根据对象的内存地址经哈希算法得来的。一般涉及到HashMap、HashSet和Hashtable 时重写equals和hashcode方法，因为类只重写equals方法，两个相同的对象的hashcode值不同在存入到这几个集合时会认定为是两个不同的元素。同时重写hashcode方法能够提高其他方法的效率。</p><h1 id="map的分类和常见的情况"><a class="markdownIt-Anchor" href="#map的分类和常见的情况"></a> map的分类和常见的情况</h1><p>java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap Hashtable LinkedHashMap 和TreeMap.</p><p>Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。</p><p>Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。</p><p>Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。</p><p>LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。</p><p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。</p><p>一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列.</p><p>HashMap是一个最常用的Map，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为NULL，允许多条记录的值为NULL。</p><p>HashMap不支持线程同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致性。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。</p><p>Hashtable与HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。</p><p>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。</p><p>在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的。</p><h1 id="java里面的final关键字是怎么用的"><a class="markdownIt-Anchor" href="#java里面的final关键字是怎么用的"></a> java里面的final关键字是怎么用的？</h1><p>final可以修饰类、方法、变量，当修饰类时，该类不能被继承；</p><p>当修饰方法时，该方法不能被重写；</p><p>当修饰的变量为基本类型时，该基本类型的值在初始化后不能改变，当修饰的变量为引用类型时，变量初始化后不能再指向其他对象，但指向的对象值可以改变，例如StringBuffer类。final修饰的变量必须显示的初始化，有两种初始化方式，一种是在变量声明的时候初始化；第二种是在声明变量的时候不赋初值，在这个变量所在的类(及其子类)所有构造函数中对这个变量赋初值。</p><h1 id="方法覆盖overriding和方法重载overloading的含义"><a class="markdownIt-Anchor" href="#方法覆盖overriding和方法重载overloading的含义"></a> 方法覆盖(Overriding)和方法重载(Overloading)的含义</h1><p>方法覆盖发生在子类中，必须有相同的方法名、返回类型以及参数列表，访问权限不能小于父类；方法重载发生在同一个类当中，与权限修饰符及返回值类型无关，与参数的个数、类型以及顺序(当所有参数类型相同时无效)有关。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA SE </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法挑战——Excel表列序号</title>
      <link href="/2019/08/22/16/"/>
      <url>/2019/08/22/16/</url>
      
        <content type="html"><![CDATA[<h2>Excel表列序号</h2><h3>类型:math</h3><h3>给定一个Excel表格中的列名称,返回其相应的列序号.</h3><p><b>例如,</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><b>示例1:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;A&quot;</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><b>示例2:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;AB&quot;</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><p><b>示例3:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;ZY&quot;</span><br><span class="line">输出: 701</span><br></pre></td></tr></table></figure><h2>解析:</h2>对传入参数进行判断,长度小于1时,直接返回Unicode码减去64,若是长度大于1,每一位都是Unicode码减去64乘以26的length-索引-1次方, 叠加后返回结果.<h3>方法1:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            res=s.charAt(<span class="number">0</span>)-<span class="number">64</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; length; i++)&#123;</span><br><span class="line">                res+=(s.charAt(i)-<span class="number">64</span>)*Math.pow(<span class="number">26</span>,length-i-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法挑战——一年中的第几天</title>
      <link href="/2019/08/20/15/"/>
      <url>/2019/08/20/15/</url>
      
        <content type="html"><![CDATA[<h2>一年中的第几天</h2><h3>类型:Unknown</h3><h3>给你一个按YYYY-MM-DD格式表示日期的字符串date,请你计算并返回该日期是当年的第几天.通常情况下,我们认为1月1日是每年的第1天,1月2日是每年的第 2 天,依此类推.每个月的天数与现行公元纪年法(格里高利历)一致.</h3><p><b>示例1:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：date = &quot;2019-01-09&quot;</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><b>示例2:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：date = &quot;2019-02-10&quot;</span><br><span class="line">输出：41</span><br></pre></td></tr></table></figure><p><b>示例3:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：date = &quot;2003-03-01&quot;</span><br><span class="line">输出：60</span><br></pre></td></tr></table></figure><p><b>示例4:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：date = &quot;2004-03-01&quot;</span><br><span class="line">输出：61</span><br></pre></td></tr></table></figure><p><b>提示:<br>date.length == 10<br>date[4] == date[7] == ‘-’，其他的 date[i] 都是数字.<br>date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日.</b></p><h2>解析:</h2>对传入参数进行分割,获得年、月、日对月份进行判断然后判断是否为闰年且月份超过2月份,是则加1,最后添加当月日期.<h3>方法1:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dayOfYear</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">        String[] arr=date.split(<span class="string">"-"</span>);</span><br><span class="line">        <span class="keyword">int</span> year=Integer.parseInt(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> month=Integer.parseInt(arr[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> day=Integer.parseInt(arr[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">int</span> days=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(month)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            days+=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            days+=<span class="number">31</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            days+=<span class="number">59</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            days+=<span class="number">90</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            days+=<span class="number">120</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            days+=<span class="number">151</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            days+=<span class="number">181</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            days+=<span class="number">212</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            days+=<span class="number">243</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            days+=<span class="number">273</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            days+=<span class="number">304</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">            days+=<span class="number">334</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(((year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)||(year%<span class="number">400</span>==<span class="number">0</span>))&amp;&amp;month&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            days++;</span><br><span class="line">        &#125; </span><br><span class="line">        days+=day;</span><br><span class="line">        <span class="keyword">return</span> days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法挑战——赎金信</title>
      <link href="/2019/08/14/fourteen-2019-8-14-2/"/>
      <url>/2019/08/14/fourteen-2019-8-14-2/</url>
      
        <content type="html"><![CDATA[<h2>赎金信</h2><h3>类型:string</h3><h3>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串,判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成.如果可以构成,返回true;否则返回false.(题目说明:为了不暴露赎金信字迹,要从杂志上搜索各个需要的字母,组成单词来表达意思.)</h3><p><b>注意</b><br>你可以假设两个字符串均只含有小写字母.</p><p><b>示例:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false</span><br><span class="line">canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false</span><br><span class="line">canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</span><br></pre></td></tr></table></figure><h2>解析:</h2>sb.deleteCharAt(sb.indexOf(ransomNote.charAt(i)+"")),找到第一个包含该字符串的位置并删除,确保正确的判断相同元素个数是否相同.<h3>方法1:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(magazine);</span><br><span class="line">        <span class="keyword">int</span> length = ransomNote.length();</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(magazine.contains(ransomNote.charAt(i)+<span class="string">""</span>))&#123;</span><br><span class="line">                num++;</span><br><span class="line">                magazine=(sb.deleteCharAt(sb.indexOf(ransomNote.charAt(i)+<span class="string">""</span>))).toString();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法挑战——猜数字大小</title>
      <link href="/2019/08/14/Thirteen-2019-8-14/"/>
      <url>/2019/08/14/Thirteen-2019-8-14/</url>
      
        <content type="html"><![CDATA[<h2>猜数字大小</h2><h3>类型:binary-search</h3><h3>我们正在玩一个猜数字游戏.游戏规则如下：我从1到n选择一个数字.你需要猜我选择了哪个数字.每次你猜错了,我会告诉你这个数字是大了还是小了.你调用一个预先定义好的接口 guess(int num),它会返回3个可能的结果((-1,1或0):</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1 : 我的数字比较小</span><br><span class="line"> 1 : 我的数字比较大</span><br><span class="line"> 0 : 恭喜！你猜对了！</span><br></pre></td></tr></table></figure><p><b>示例:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n = 10, pick = 6</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><h2>解析:</h2>在解题过程中需要注意溢出,解决方法有:(left-right)/2,或者(left+right)>>>1.<h3>方法1:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>,right=n,res,num;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            res=left +(right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(guess(res)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(guess(res)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                right = res -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = res +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法挑战——最大连续1的个数</title>
      <link href="/2019/08/13/twelve-2019-8-13/"/>
      <url>/2019/08/13/twelve-2019-8-13/</url>
      
        <content type="html"><![CDATA[<h2>最大连续1的个数</h2><h3>类型:array</h3><h3>给定一个二进制数组,计算其中最大连续1的个数.</h3><p><b>示例1:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,0,1,1,1]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.</span><br></pre></td></tr></table></figure><p><b>注意:</b><br>1.输入的数组只包含0和1.<br>2.输入数组的长度是正整数,且不超过10,000.</p><h2>解析:</h2>注意传入数组中最后一个元素的判断.<h3>方法1:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">if</span>(i==nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    arr[j]=num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr[j]=num;</span><br><span class="line">                num=<span class="number">0</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k &lt; arr.length; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[k]&gt;max)&#123;</span><br><span class="line">                max = arr[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法挑战——三个数的最大乘积</title>
      <link href="/2019/08/12/eleven-2019-8-12-2/"/>
      <url>/2019/08/12/eleven-2019-8-12-2/</url>
      
        <content type="html"><![CDATA[<h2>三个数的最大乘积</h2><h3>类型:array|math</h3><h3>给定一个整型数组,在数组中找出由三个数组成的最大乘积,并输出这个乘积.</h3><p><b>示例1:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><b>示例2:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: 24</span><br></pre></td></tr></table></figure><p><b>注意:</b><br>1.给定的整型数组长度范围是[3,104],数组中所有的元素范围是[-1000, 1000].<br>2.输入的数组中任意三个数的乘积不会超出32位有符号整数的范围.</p><h2>解析:</h2>首先对传入的数组进行升序排序,判断负数的个数,如果负数个数小于1,那么结果为数组末尾3个数的乘积,否则比较末尾3个数乘积与第一、二和最后一个数三个数乘积的大小,返回最大数.<h3>方法1:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> length=nums.length;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>,num1=<span class="number">0</span>,num2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">if</span>(num&gt;<span class="number">1</span>)&#123;</span><br><span class="line">           num1=nums[<span class="number">0</span>]*nums[<span class="number">1</span>]*nums[length-<span class="number">1</span>];</span><br><span class="line">           num2=nums[length-<span class="number">1</span>]*nums[length-<span class="number">2</span>]*nums[length-<span class="number">3</span>];</span><br><span class="line">           <span class="keyword">if</span>(num1&gt;=num2)&#123;</span><br><span class="line">               <span class="keyword">return</span> num1;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> num2;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> nums[length-<span class="number">1</span>]*nums[length-<span class="number">2</span>]*nums[length-<span class="number">3</span>];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法挑战——平方数之和</title>
      <link href="/2019/08/12/ten-2019-8-12/"/>
      <url>/2019/08/12/ten-2019-8-12/</url>
      
        <content type="html"><![CDATA[<h2>平方数之和</h2><h3>类型:math</h3><h3>给定一个非负整数c,你要判断是否存在两个整数a和b,使得a^2+b^2=c.</h3><p><b>示例1:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: True</span><br><span class="line">解释: 1 * 1 + 2 * 2 = 5</span><br></pre></td></tr></table></figure><p><b>示例2:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><h2>解析:</h2>起初在编写代码时总是出现超时的情况,百度发现所有解法中j的取值都没有超过c/2,这时才发现当J超过c/2必然为false,于是将j的取值范围定义为0-c/2,同时判断j^2是否大于c,若大于则直接返回false.<br>方法2的思路更为清晰,减少了Math.sqrt()方法的调用,方法更好.<h3>方法1:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> j=<span class="number">0</span>;j&lt;=c/<span class="number">2</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j*j&gt;c)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">double</span> s=Math.sqrt(c-j*j);</span><br><span class="line">                <span class="keyword">if</span>(s%<span class="number">1</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>解法2:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = (<span class="keyword">int</span>) Math.sqrt(c);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*i+j*j==c)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i*i+j*j&lt;c)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法挑战——自除数</title>
      <link href="/2019/08/10/nine-2019-8-10/"/>
      <url>/2019/08/10/nine-2019-8-10/</url>
      
        <content type="html"><![CDATA[<h2>自除数</h2><h3>类型:math</h3><h3>自除数 是指可以被它包含的每一位数除尽的数.例如,128是一个自除数,因为128%1 == 0,128%2==0,128%8==0.还有,自除数不允许包含0.给定上边界和下边界数字,输出一个列表,列表的元素是边界(含边界)内所有的自除数.</h3><p><b>示例1:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">上边界left = 1,下边界right = 22</span><br><span class="line">输出:[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]</span><br></pre></td></tr></table></figure><p><b>注意:</b></p><h4>每个输入参数的边界满足1 < = left < = right < = 10000.</h4><h2>解析:</h2><h3>方法1:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">selfDividingNumbers</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">            String s=i+<span class="string">""</span>;</span><br><span class="line">            <span class="keyword">int</span> length=s.length();</span><br><span class="line">            <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> l=Integer.parseInt(s.charAt(j)+<span class="string">""</span>);</span><br><span class="line">                <span class="keyword">if</span>(l==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i%l==<span class="number">0</span>)&#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num==length)&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法挑战——缺失数字</title>
      <link href="/2019/08/09/eight-2019-8-9/"/>
      <url>/2019/08/09/eight-2019-8-9/</url>
      
        <content type="html"><![CDATA[<h2>缺失数字</h2><h3>类型:array|math|bit-manipulation</h3><h3>给定一个包含0, 1, 2, ..., n中n个数的序列,找出 0 .. n中没有出现在序列中的那个数.</h3><p><b>示例1:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><b>示例2:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><p><b>说明:</b></p><h4>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</h4><h2>解析:</h2><h3>方法1:</h3>先对传入的数组进行排序,然后通过对比找到中间缺失的数字,如果是末尾缺失则取数组最后一个数加一得到结果.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> res=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=nums[i])&#123;</span><br><span class="line">                res=nums[i]-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res==-<span class="number">1</span>)&#123;</span><br><span class="line">            res=nums[nums.length-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法挑战——下一个更大元素-I</title>
      <link href="/2019/08/08/seven-2019-8-8-3/"/>
      <url>/2019/08/08/seven-2019-8-8-3/</url>
      
        <content type="html"><![CDATA[<h2>下一个更大元素-I</h2><h3>类型:stack</h3><h3>给定两个没有重复元素的数组nums1和nums2,其中nums1是nums2 的子集.找到nums1中每个元素在nums2中的下一个比其大的值.<p>nums1中数字x的下一个更大元素是指x在nums2中对应位置的右边的第一个比x大的元素.如果不存在,对应位置输出-1.</p></h3><p></p><p><b>示例1:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字4,你无法在第二个数组中找到下一个更大的数字,因此输出-1.</span><br><span class="line">    对于num1中的数字1,第二个数组中数字1右边的下一个较大数字是 3.</span><br><span class="line">    对于num1中的数字2,第二个数组中没有下一个更大的数字,因此输出-1.</span><br></pre></td></tr></table></figure><p><b>示例2:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字2,第二个数组中的下一个较大数字是3.</span><br><span class="line">    对于num1中的数字4,第二个数组中没有下一个更大的数字,因此输出-1.</span><br></pre></td></tr></table></figure><p><b>注意:</b><br></p><h4>1.nums1和nums2中所有元素是唯一的.</h4><br><h4>2.nums1和nums2的数组大小都不超过1000.</h4><p></p><h2>解析:</h2><h3>方法1:</h3>创建一个同等于nums1长度的数组arr并初始化值-1,接下来再创建一个于nums2元素相同的动态数组,<font color="#01AAED">动态数组的indexOf()方法可以通过值获得索引</font>,接下来判断索引的位置,如果为动态数组的末尾则continue结束本次循环,否则找到下一个更大元素并存入arr数组中,当遇到第一个更大元素即break跳出本层循环.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr= <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;arr.length;a++)&#123;</span><br><span class="line">            arr[a]=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b:nums2)&#123;</span><br><span class="line">            arrayList.add(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=arrayList.indexOf(nums1[i]);</span><br><span class="line">            <span class="keyword">if</span>(index==arrayList.size()-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=index+<span class="number">1</span>;j&lt;arrayList.size();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums2[j]&gt;nums1[i])&#123;</span><br><span class="line">                        arr[i]=nums2[j];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法挑战——七进制数</title>
      <link href="/2019/08/08/six-2019-8-8-2/"/>
      <url>/2019/08/08/six-2019-8-8-2/</url>
      
        <content type="html"><![CDATA[<h2>七进制数</h2><h3>类型:math</h3><h3>给定一个整数，将其转化为7进制,并以字符串形式输出.</h3><p><b>示例1:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 100</span><br><span class="line">输出: &quot;202&quot;</span><br></pre></td></tr></table></figure><p><b>示例2:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: -7</span><br><span class="line">输出: &quot;-10&quot;</span><br></pre></td></tr></table></figure><h2>解析:</h2><h3>方法1:</h3>七进制数顾名思义就是逢七进一,首先将负数转换成正数再统一处理,最后判断参数为正数还是负数,负数则在头部添加'-'号.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuilder sBuilder=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> num2=Math.abs(num);</span><br><span class="line">        <span class="keyword">while</span>(num2&gt;=<span class="number">7</span>)&#123;</span><br><span class="line">            sBuilder.append(num2%<span class="number">7</span>+<span class="string">""</span>);</span><br><span class="line">            num2=num2/<span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sBuilder.append(num2+<span class="string">""</span>);</span><br><span class="line">        sBuilder.reverse();</span><br><span class="line">        <span class="keyword">if</span>(num&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sBuilder.toString();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sBuilder.insert(<span class="number">0</span>, <span class="string">'-'</span>);</span><br><span class="line">            <span class="keyword">return</span> sBuilder.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法挑战——求众数</title>
      <link href="/2019/08/08/five-2019-8-8/"/>
      <url>/2019/08/08/five-2019-8-8/</url>
      
        <content type="html"><![CDATA[<h2>求众数</h2><h3>类型:array | divide-and-conquer | bit-manipulation</h3><h3>给定一个大小为 n 的数组,找到其中的众数.众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素.<p>你可以假设数组是非空的,并且给定的数组总是存在众数.</p></h3><p></p><p><b>示例1:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><b>示例2:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><h2>解析:</h2><h3>方法1:</h3>目前没有想到比较好的解决方法,仅有一个比较低级的解法,首先通过hashtable对象存储数组中元素以及元素出现的次数,获取hashtable中所有value的值存储到Collection对象中,转换成Integer数组获取元素中最大的值,最后通过比较找到值所对应的键并返回,<font color="#01AAED">此解法违背了hashtable的设计初衷(通过key来获得value).</font><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Hashtable&lt;Integer,Integer&gt; hashtable=<span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashtable.containsKey(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">int</span> a=(Integer)hashtable.get(nums[i]);</span><br><span class="line">                a++;</span><br><span class="line">                hashtable.put(nums[i],a);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hashtable.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collection col=hashtable.values();</span><br><span class="line">        Integer[] arr=<span class="keyword">new</span> Integer[col.size()];</span><br><span class="line">        col.toArray(arr);</span><br><span class="line">        <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;max)&#123;</span><br><span class="line">                max=arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;nums.length;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashtable.get(nums[k])==max)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法挑战——两数之和</title>
      <link href="/2019/07/29/four-2019-7-29-2/"/>
      <url>/2019/07/29/four-2019-7-29-2/</url>
      
        <content type="html"><![CDATA[<h2>两数之和</h2><h3>类型:array|hash-table</h3><h3>给定一个整数数组nums和一个目标值target,请你在该数组中找出和为目标值的那两个整数,并返回他们的数组下标.<p>你可以假设每种输入只会对应一个答案.但是,你不能重复利用这个数组中同样的元素.</p></h3><p></p><p><b>示例:</b></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums = [2,7,11,15],target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0,1]</span><br></pre></td></tr></table></figure><h2>解析:</h2><h3>方法1:</h3><p>我们可以利用数组嵌套的方式暴力解题,方法如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的时间复杂度为O(n^2),不是特别理想,我们可以试一试下面这种方法.</p><h3>方法2:</h3><p>利用Hashtable的特性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Hashtable&lt;Integer,Integer&gt; hashtable=<span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashtable.containsKey(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hashtable.get(nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(target-nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见第二种方法的时间复杂度O(n)为更优的解法.</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法挑战——只出现一次的数字</title>
      <link href="/2019/07/29/Three-2019-7--29/"/>
      <url>/2019/07/29/Three-2019-7--29/</url>
      
        <content type="html"><![CDATA[<h2>只出现一次的数字</h2><h3>类型:hash-table|bit-manipulation</h3><h3>给定一个非空整数数组,除了某个元素只出现一次以外,其余每个元素均出现两次.找出那个只出现了一次的元素.<p><b>说明:</b></p><p>你的算法应该具有线性时间复杂度.你可以不使用额外空间来实现吗?</p></h3><p></p><p><b>示例 1:</b></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><b>示例 2:</b></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h2>解析:</h2><h3>方法1:</h3><p>由题可知,我们使用的算法要求采用线性时间复杂度O(n),且空间复杂度为O(1).那么我们可以使用异或(^)运算来解题,<font color="#1E9FFF">异或运算的法则是:相同为0,不同为1.</font></p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">P</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p>不难得出任意一个数与0异或结果都是这个数本身,任意一个数与其本身异或结果都是0,例如4与3异或(100 ^ 011=111)再与4异或(111 ^ 100=011)结果为3,通过异或可以得到数组中唯一的只出现一次的数.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            result^=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Solution s=<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> a=s.singleNumber(&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Hexo+github page快速搭建个人博客?</title>
      <link href="/2019/07/19/Second-2019-7-19/"/>
      <url>/2019/07/19/Second-2019-7-19/</url>
      
        <content type="html"><![CDATA[<h2>1.前言</h2><h3>1.1为什么选择github page搭建博客？</h3><blockquote><p>1.搭建简单,免费使用;<br><br>2.静态项目,访问速度快;<br><br>3.支持绑定你的域名;<br><br>4.基于github的版本管理,随时恢复以前的版本,且数据安全;<br><br>5.可以轻松的将博客打包,发布到其他平台.<br></p></blockquote><h3>1.2准备事项</h3><blockquote><p>1.创建个人github账户;<br><br>2.下载node.js、git for windows;</p></blockquote><h2>2.搭建github博客</h2><h3>2.1创建github仓库</h3>登录<a href="https://www.github.com" target="_blank" rel="noopener">github</a>创建一个名为<font color="#5FB878">用户名.github.io</font>仓库,例如：github用户名为text,那么仓库名则为<font color="#5FB878">text.github.io</font>,注意：一个github账号只能创建一个可以直接使用域名访问的仓库，创建完成后我们就可以进行下一步操作了。<p><img alt="1.png" data-src="https://s2.ax1x.com/2019/07/19/ZxYIu4.png" class="lozad"></p><p><img alt="2.png" data-src="https://s2.ax1x.com/2019/07/19/ZxtrRK.png" class="lozad"></p><h3>2.2绑定你的个人域名</h3>如果你不想使用个人域名访问你的博客，可以略过此步骤，个人域名可以通过<a href="https://www.aliyun.com" target="_blank" rel="noopener">阿里云</a>、<a href="https://cloud.tencent.com/" target="_blank" rel="noopener">腾讯云</a>等购买，初次购买有很大的优惠。接下来我们前往域名供应商控制台进行域名解析操作（以腾讯云为例）：CNAME填写github仓库域名，A记录填写IP，由于我们不知道自己的github仓库域名IP，我们可以通过ping来获取，到你的github仓库根目录创建一个名为CNAME的文件（无后缀文件），内容为你购买的域名，然后绑定我们的域名。<p><img alt="3.png" data-src="https://s2.ax1x.com/2019/07/19/ZxYNNt.png" class="lozad"></p><p><img alt="4.png" data-src="https://s2.ax1x.com/2019/07/19/ZxGGxe.png" class="lozad"></p><p><img alt="5.png" data-src="https://s2.ax1x.com/2019/07/20/ZzPJUI.png" class="lozad"></p><p><img alt="6.png" data-src="https://s2.ax1x.com/2019/07/19/Zx8w3F.png" class="lozad"></p><p><img alt="7.png" data-src="https://s2.ax1x.com/2019/07/20/Zzp5qA.png" class="lozad"></p><p><img alt="8.png" data-src="https://s2.ax1x.com/2019/07/20/Zzpxqs.png" class="lozad"></p><p><img alt="9.png" data-src="https://s2.ax1x.com/2019/07/20/ZzCOBj.png" class="lozad"></p><p><img alt="10.png" data-src="https://s2.ax1x.com/2019/07/20/ZzCXHs.png" class="lozad"></p><p>接下来会看到我们站点更新了</p><p><img alt="11.png" data-src="https://s2.ax1x.com/2019/07/20/ZzPjMD.png" class="lozad"></p><h2>3.安装及配置</h2><h3>3.1安装git</h3>1.官方：https://git-scm.com/download/win <br>2.淘宝NPM镜像：https://npm.taobao.org/mirrors/git-for-windows/    （推荐使用，下载速度快）<p><img alt="12.png" data-src="https://s2.ax1x.com/2019/07/19/ZxrXTS.png" class="lozad"></p><p>勾选additional icons方便使用</p><p><img alt="13.png" data-src="https://s2.ax1x.com/2019/07/19/ZxrzWj.png" class="lozad"></p><p><img alt="14.png" data-src="https://s2.ax1x.com/2019/07/20/ZxsulR.png" class="lozad"></p><p>直接Next，安装结束。</p><h3>3.2安装Node.js</h3>1.官方（国外）：https://nodejs.org/en/ <br>2.官方（国内）：http://nodejs.cn/download/ <br>3.淘宝NPM镜像：https://npm.taobao.org/mirrors/node<p><img alt="15.png" data-src="https://s2.ax1x.com/2019/07/20/Zxsgpj.png" class="lozad"></p><p>同样，直接Next，安装结束。</p><h3>3.3安装Hexo</h3>在本地磁盘创建一个Hexo文件夹存储本地文件<p><img alt="16.png" data-src="https://s2.ax1x.com/2019/07/20/ZxySAO.png" class="lozad"></p><p>进入该文件夹下右击打开Git命令</p><p><img alt="17.png" data-src="https://s2.ax1x.com/2019/07/20/ZxynUS.png" class="lozad"></p><p>安装Hexo</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>完成后，Hexo文件夹下会生成数个文件</p><p><a href="https://imgchr.com/i/Zx6foT" target="_blank" rel="noopener"><img alt="18.png" data-src="https://s2.ax1x.com/2019/07/20/Zx6foT.png" class="lozad"></a></p><p>执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>hexo g是hexo generate的简写，用来生成静态文件；hexo d是hexo deploy的简写，用来部署网站；hexo s是hexo server的简写，用来启动服务器，默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82" target="_blank" rel="noopener">http://localhost:4000/。</a> 这三个指令非常重要，经常会使用到。</p> <h3>3.4配置git</h3> 进入git bash命令配置我们的git参数，设置git姓名和邮箱（填写你的github用户名以及github注册邮箱）。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name "your_name"</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.email "your_email@XX.com"</span><br></pre></td></tr></table></figure><p>由于github上连接仓库的验证是通过SSH的公开密钥来认证的，因此我们要配置自己的SSH Key，</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "your_email@XX.com"</span><br></pre></td></tr></table></figure><p>三次回车之后会自动生成一个.ssh文件在用户目录下，进入用户目录（/Users/your_user/.ssh）找到id_rsa.pub文件并用记事本打开，复制密钥</p><p><img alt="19.png" data-src="https://s2.ax1x.com/2019/07/20/ZzPJUI.png" class="lozad"></p><p><img alt="20.png" data-src="https://s2.ax1x.com/2019/07/20/ZzVUGn.png" class="lozad"></p><p><img alt="21.png" data-src="https://s2.ax1x.com/2019/07/20/ZzVDqU.png" class="lozad"></p><p>复制一下代码检测是否添加成功</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>当提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会提示：</p><p>Hi  XXX! You’ve successfully authenticated, but GitHub does not provide shell access.<br>这里很多人会直接回车导致连接失败。</p><p>修改_config.yml<br>打开创建的Hexo文件夹找到_config.yml用记事本打开，找到deploy关键项，修改以下内容</p><p><img alt="22.png" data-src="https://s2.ax1x.com/2019/07/20/Zzme54.png" class="lozad"></p><p>repository项可以通过github的项目目录下查看</p><p><img alt="23.png" data-src="https://s2.ax1x.com/2019/07/20/ZzmaRA.png" class="lozad"></p><p><font color="#5FB878">注意，yml文件下名称后留有空格，如果没有保留空格会导致无效。</font></p><p>替换之后，部署git</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>到此，我们的个人博客创建完成。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/18/hello-world/"/>
      <url>/2019/07/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
